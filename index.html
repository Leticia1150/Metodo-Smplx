// Eliminar duplicados y ordenar para formar un polígono cerrado
const uniqueVertices = [];
vertices.forEach(p => {
  if (!uniqueVertices.some(v => Math.abs(v.x - p.x) < 0.001 && Math.abs(v.y - p.y) < 0.001)) {
    uniqueVertices.push(p);
  }
});

// Ordenar puntos en sentido horario o antihorario para formar la región cerrada
const cx = uniqueVertices.reduce((sum, p) => sum + p.x, 0) / uniqueVertices.length;
const cy = uniqueVertices.reduce((sum, p) => sum + p.y, 0) / uniqueVertices.length;

uniqueVertices.sort((a, b) => {
  const angleA = Math.atan2(a.y - cy, a.x - cx);
  const angleB = Math.atan2(b.y - cy, b.x - cx);
  return angleA - angleB;
});

// Pintar solo la región correcta
const trace_region = {
  x: [...uniqueVertices.map(p => p.x), uniqueVertices[0].x], // cerrar el polígono
  y: [...uniqueVertices.map(p => p.y), uniqueVertices[0].y],
  fill: 'toself',
  name: 'Región Factible',
  fillcolor: 'rgba(173,216,230,0.4)',
  line: { color: '#3182bd' },
  type: 'scatter',
  mode: 'lines+markers+text',
  marker: { size: 8, color: '#3182bd' },
  text: uniqueVertices.map((p, i) => `V${i + 1} (${p.x.toFixed(2)}, ${p.y.toFixed(2)})`),
  textposition: 'top right'
};
